---
title: 'Attachments'
description: 'Download email attachments'
---

## Download Attachment

<CodeGroup>
```bash cURL
curl -X GET "https://api.inbound.new/api/e2/attachments/eml_abc123/report.pdf" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  --output report.pdf
```

```typescript TypeScript SDK
import { Inbound } from '@inbound/sdk'

const inbound = new Inbound({ apiKey: 'YOUR_API_KEY' })

// Download attachment
const attachment = await inbound.attachments.download(
  'eml_abc123',
  'report.pdf'
)

// Save to file
await Bun.write('report.pdf', attachment)
```

```javascript JavaScript - Fetch
const response = await fetch(
  'https://api.inbound.new/api/e2/attachments/eml_abc123/report.pdf',
  {
    headers: {
      'Authorization': 'Bearer YOUR_API_KEY'
    }
  }
)

if (response.ok) {
  const blob = await response.blob()
  // Save or process the blob
}
```
</CodeGroup>

### GET `/api/e2/attachments/:id/:filename`

Download an email attachment by email ID and filename. Returns the binary file content with appropriate Content-Type and Content-Disposition headers.

#### Path Parameters

<ParamField path="id" type="string" required>
  Email ID that contains the attachment.
  
  Example: `eml_abc123`
</ParamField>

<ParamField path="filename" type="string" required>
  Filename of the attachment to download. Will be URL-decoded automatically.
  
  Example: `report.pdf` or `My%20Document.docx`
</ParamField>

#### Response

Returns binary file content with appropriate headers:

**Response Headers:**

<ResponseField name="Content-Type" type="string">
  MIME type of the attachment (e.g., `application/pdf`, `image/png`, `text/plain`).
  
  Falls back to `application/octet-stream` if unknown.
</ResponseField>

<ResponseField name="Content-Disposition" type="string">
  Attachment disposition with filename. Uses both ASCII fallback and UTF-8 encoded filename per RFC 5987.
  
  Example: `attachment; filename="report.pdf"; filename*=UTF-8''report.pdf`
</ResponseField>

<ResponseField name="Content-Length" type="string">
  Size of the attachment in bytes.
</ResponseField>

<ResponseField name="Cache-Control" type="string">
  Cache control header: `private, max-age=3600`
</ResponseField>

**Response Body:**

Raw binary content of the attachment.

---

## Attachment Storage

Attachments are stored in two possible locations:

1. **Amazon S3** (Primary) - For emails stored in S3 buckets
2. **Database** (Fallback) - For emails with inline content

The API automatically:
- Tries S3 first if bucket and key are available
- Falls back to database content if S3 fetch fails
- Returns appropriate error if neither source is available

---

## Size Limits

<Note>
  The maximum attachment size is determined by your email provider's limits:
  - **AWS SES**: 10 MB per email (including all attachments)
  - **Individual attachments**: No specific limit, but total email size must not exceed 10 MB
</Note>

---

## Supported Formats

All attachment types are supported. Common MIME types:

| Format | MIME Type | Extension |
|--------|-----------|----------|
| PDF | `application/pdf` | `.pdf` |
| Word Document | `application/vnd.openxmlformats-officedocument.wordprocessingml.document` | `.docx` |
| Excel Spreadsheet | `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet` | `.xlsx` |
| PowerPoint | `application/vnd.openxmlformats-officedocument.presentationml.presentation` | `.pptx` |
| ZIP Archive | `application/zip` | `.zip` |
| PNG Image | `image/png` | `.png` |
| JPEG Image | `image/jpeg` | `.jpg`, `.jpeg` |
| GIF Image | `image/gif` | `.gif` |
| Text File | `text/plain` | `.txt` |
| CSV File | `text/csv` | `.csv` |
| JSON File | `application/json` | `.json` |

---

## Error Responses

<ResponseField name="error" type="string">
  Error message describing what went wrong.
</ResponseField>

<ResponseField name="details" type="string">
  Additional error details (if available).
</ResponseField>

### Common Error Scenarios

**404 - Email Not Found**
```json
{
  "error": "Email not found or access denied"
}
```

**404 - Attachment Not Found**
```json
{
  "error": "Attachment not found"
}
```

**404 - No Attachments**
```json
{
  "error": "No attachments found in this email"
}
```

**404 - Email Content Not Available**
```json
{
  "error": "Email content not available"
}
```

**401 - Unauthorized**
```json
{
  "error": "Unauthorized",
  "details": "Invalid or missing API key"
}
```

---

## Listing Email Attachments

To get a list of attachments for an email, use the [Get Email](/api-reference/emails) endpoint:

```typescript
const email = await inbound.emails.get('eml_abc123')

if (email.has_attachments) {
  console.log('Attachments:', email.attachments)
  // [
  //   {
  //     filename: 'report.pdf',
  //     contentType: 'application/pdf',
  //     size: 245678,
  //     contentId: null
  //   },
  //   ...
  // ]
}
```

Then download each attachment:

```typescript
for (const attachment of email.attachments) {
  const file = await inbound.attachments.download(
    email.id,
    attachment.filename
  )
  
  await Bun.write(`downloads/${attachment.filename}`, file)
}
```

---

## Inline Attachments

Inline attachments (images embedded in HTML emails) have a `contentId` field:

```json
{
  "filename": "logo.png",
  "contentType": "image/png",
  "size": 15234,
  "contentId": "<logo@example.com>"
}
```

These can still be downloaded using the same endpoint, but they're also referenced in the HTML body:

```html
<img src="cid:logo@example.com" alt="Logo">
```

---

## Security

- **Authentication Required**: All attachment downloads require a valid API key
- **User Scoping**: Users can only download attachments from their own emails
- **Content Validation**: Filenames are URL-decoded and validated
- **Binary Safety**: Files are returned as-is without modification
- **Private Caching**: Cache-Control header set to `private` to prevent public caching

---

## Best Practices

1. **Check Email First**: Use the Get Email endpoint to verify attachments exist before downloading
2. **Handle Large Files**: Implement streaming for large attachment downloads
3. **Validate Content-Type**: Always check the Content-Type header before processing
4. **URL Encode Filenames**: Encode special characters in filenames when constructing URLs
5. **Error Handling**: Implement proper error handling for missing or inaccessible attachments

```typescript
// Example: Safe attachment download
async function downloadAttachment(emailId: string, filename: string) {
  try {
    // URL encode the filename
    const encodedFilename = encodeURIComponent(filename)
    
    const response = await fetch(
      `https://api.inbound.new/api/e2/attachments/${emailId}/${encodedFilename}`,
      {
        headers: {
          'Authorization': `Bearer ${process.env.INBOUND_API_KEY}`
        }
      }
    )
    
    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error)
    }
    
    // Check content type
    const contentType = response.headers.get('Content-Type')
    console.log('Downloading:', contentType)
    
    // Get binary data
    const blob = await response.blob()
    
    // Save to file
    await Bun.write(`downloads/${filename}`, blob)
    
    return { success: true, filename, size: blob.size }
  } catch (error) {
    console.error('Download failed:', error)
    return { success: false, error: error.message }
  }
}
```